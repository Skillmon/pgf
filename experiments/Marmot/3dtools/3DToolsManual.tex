\documentclass[a4paper]{ltxdoc}
%\input{pgfmanual-dvipdfm.cfg}
%\input{../../text-en/pgfmanual-en-main-preamble}
\usepackage[version=latest]{pgf}
\usepackage{xkeyval,calc,listings,tikz,fp}
\usepackage{makeidx}
\makeindex
\usepackage{hyperref}
\hypersetup{%
        colorlinks=true,
        linkcolor=blue,
        filecolor=blue,
        urlcolor=blue,
        citecolor=blue,
        pdfborder=0 0 0,
}
\makeatletter          % see https://tex.stackexchange.com/q/33946
\input{pgfmanual.code} % 
\makeatother           % 
\input{pgfmanual-en-macros.tex} % link from
% /usr/local/texlive/2019/texmf-dist/doc/generic/pgf/macros/pgfmanual-en-macros.tex
% or the equivalent on your installation
\def\pgfautoxrefs{1}
\usetikzlibrary{3dtools}
\begin{document}
\section{3D Tools}
\begin{tikzlibrary}{3dtools}
    This library provides additional tools to create 3d--like pictures.
\end{tikzlibrary}

TikZ has the |3d| and |tpp| libraries which deal with the projections of
three--dimensional drawings. This library provides some means to manipulate
the coordinates. It supports linear combinations of vectors, vector and scalar
products.

\noindent\textbf{Note:} Hopefully this library is only temporary and its
contents will be absorbed in slightly extended versions of the |3d| and |calc|
libraries.

\subsection{Coordinate computations}
\label{sec:3DCoordinateComputations}


The |3dtools| library has some options and styles for coordinate computations.
\begin{key}{/tikz/3d parse}
        Parses and expression and inserts the result in form of a coordinate.
\end{key}
\begin{key}{/tikz/3d coordinate}
        Allow one to define a 3d coordinate from other coordinates.
\end{key}
Both keys support both symbolic and explicit coordinates but for the explicit
ones one needs additional braces.

\begin{codeexample}[width=6cm]
\begin{tikzpicture}
 \path (1,2,3) coordinate (A) 
  (2,3,-1) coordinate (B) 
  (-1,-2,1) coordinate (C)
  [3d parse={0.25*(1,2,3)x(B)}] 
  	coordinate(D)
  [3d parse={0.25*(C)x(B)}] 
  	coordinate(E);
 \path foreach \X in {A,...,E} 
 {(\X) node[fill,inner sep=1pt,
 label=above:$\X$]{}};
\end{tikzpicture}
\end{codeexample}

\begin{codeexample}[width=6cm]
\begin{tikzpicture}
 \path (1,2,3) coordinate (A) 
  (2,3,-1) coordinate (B) 
  (-1,-2,1) coordinate (C)
  [3d coordinate={(D)=0.25*(1,2,3)x(B)},
  3d coordinate={(E)=0.25*(C)x(B)}];
 \path foreach \X in {A,...,E} 
 {(\X) node[fill,inner sep=1pt,
 label=above:$\X$]{}};
\end{tikzpicture}
\end{codeexample}

The library comes also with a function |\pgfmathtdparse| that allows one to parse 3d
expressions. The supported vector operations are |+| (addition $+$), |-|
(subtraction $-$), |*| (multiplication of the vector by a scalar), |x|
(vector product $\times$) and |o| (scalar product).

\begin{command}{\pgfmathtdparse{\marg{x}}}
   Parses 3d expressions.
\end{command}


\begin{codeexample}[]
\pgfmathtdparse{(1,0,0)x(0,1,0)}\pgfmathresult
\end{codeexample}

In order to pretty-print the result one may want to use |\pgfmathprintvector|,
and use the math function |TD| for parsing.

\begin{command}{\pgfmathprintvector\marg{x}}
   Pretty-prints vectors.
\end{command}

\begin{codeexample}[width=6.5cm]
\pgfmathparse{TD("0.2*(A)
-0.3*(B)+0.6*(C)")}%
$0.2\,\vec A-0.3\,\vec B+0.6\,\vec C
=(\pgfmathprintvector\pgfmathresult)$
\end{codeexample}

The alert reader may wonder why this works, i.e.\ how would \tikzname\ ``know''
what the coordinates $A$, $B$ and $C$ are. It works because the coordinates in
\tikzname\ are global, so they get remembered from the above example.

\begin{codeexample}[width=5.2cm]
\pgfmathparse{TD("(1,0,0)x(0,1,0)")}%
$(1,0,0)^T\times(0,1,0)^T=
(\pgfmathprintvector\pgfmathresult)^T$
\end{codeexample}


\begin{codeexample}[width=5.2cm]
\pgfmathparse{TD("(A)o(B)")}%
$\vec A\cdot \vec B=
\pgfmathprintnumber\pgfmathresult$
\end{codeexample}



\end{document}

\tdplotsetmaincoords{70}{110} 
\begin{tikzpicture}
 \begin{scope}[local bounding box=tests,tdplot_main_coords]
 % to work with this library, you need to define the cordinate
 % with \path (<x>,<y>,<z>) coordinate (<name>);
  \path (0,0,0) coordinate (O) 
  (1,2,3) coordinate (A) 
  (2,3,-1) coordinate (B) 
  (-1,-2,1) coordinate (C)
  % you can use 3d parse (clumsy)
  [3d parse={0.25*(A)x(B)}] coordinate(D)
  % you can use 3d coordinate to define a new coordinate from existing ones
  [3d coordinate={(E)=0.2*(A)-0.3*(B)+0.6*(C)}] 
  [3d coordinate={(H)=0.2*(A)-0.3*(B)+0.6*(C)}]; 
  \draw (A) -- (B) -- (C) -- (D) -- (E) -- cycle; 
 \end{scope}
 %\RawCoord yields the components
 \edef\tempD{\RawCoord(D)} 
 \edef\tempE{\RawCoord(E)} 
 \edef\tempH{\RawCoord(H)} 
 \node[below right,align=left] at (tests.south west) 
  {$(D)=\tempD$,\\ $(E)=\tempE$,\\ $(H)=\tempH$}; 
\end{tikzpicture} 

\noindent% clumsy parser
$\tdparse{(A)+0.3*(B)>(A)+0.3(B)}=(\pgfmathresult)$

\noindent% parsing inside \pgfmathparse. You need to wrap the argument in "..."
\pgfmathparse{TD("0.2*(A)-0.3*(B)+0.6*(C)")}%
$0.2\,\vec A-0.3\,\vec B+0.6\vec C=(\pgfmathresult)$

%one can parse with the same parser vector products
\noindent\pgfmathparse{TD("0.5*(A)x(B)")}%
$0.5\,\vec A\times\vec B=(\pgfmathresult)$
%(note, however, that something like (A)x(B)x(C) does NOT work)

%as well as scalar products
\noindent\pgfmathparse{TD("(A)+(C)o(B)")}%
$\left(\begin{array}{@{}c@{}}1\\ 0\\ 0\end{array}\right)$
%(note, however, that + and - have higher precedence than o)\end{document}
\endinput
