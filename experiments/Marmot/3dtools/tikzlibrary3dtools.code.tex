% Copyright 2019 by an anonymous marmot
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.
\ProvidesFileRCS{tikzlibrary3dtools.code.tex}
\usetikzlibrary{fpu}% to do: ability to switch on and off
\usepackage{calculator}% maybe drop
\makeatletter%
\newcommand{\orthmat}[3]{% the entries of this matrix keep track
\pgfmathparse{cos(#1)*cos(#2)}% of the current transformation
\xdef\tikz@td@matAA{\pgfmathresult}%
\pgfmathparse{cos(#2)*sin(#1)}% 
\xdef\tikz@td@matAB{\pgfmathresult}% 
\pgfmathparse{sin(#2)}% 
\xdef\tikz@td@matAC{\pgfmathresult}%
\pgfmathparse{-cos(#3)*sin(#1)-cos(#1)*sin(#2)*sin(#3)}%
\xdef\tikz@td@matBA{\pgfmathresult}%  
\pgfmathparse{cos(#1)*cos(#3)-sin(#1)*sin(#2)*sin (#3)}% 
\xdef\tikz@td@matBB{\pgfmathresult}%
\pgfmathparse{cos(#2)*sin (#3)}%
\xdef\tikz@td@matBC{\pgfmathresult}%
\pgfmathparse{sin(#1)*sin(#3)-cos(#1)*cos(#3)*sin(#2)}%
\xdef\tikz@td@matCA{\pgfmathresult}% 
\pgfmathparse{-cos(#3)*sin(#1)*sin(#2)-cos(#1)*sin(#3)}% 
\xdef\tikz@td@matCB{\pgfmathresult}%
\pgfmathparse{cos(#2)*cos(#3)}%
\xdef\tikz@td@matCC{\pgfmathresult}}%
\tikzset{3d/.cd,alpha/.initial=0,beta/.initial=0,gamma/.initial=0,
install view/.style={/utils/exec=\tikzset{3d/.cd,#1}%
\orthmat{\pgfkeysvalueof{/tikz/3d/alpha}}{%
\pgfkeysvalueof{/tikz/3d/beta}}{\pgfkeysvalueof{/tikz/3d/gamma}},%
/tikz/x={({\tikz@td@matAA*1cm},{\tikz@td@matBA*1cm})},%
/tikz/y={({\tikz@td@matAB*1cm},{\tikz@td@matBB*1cm})},%
/tikz/z={({\tikz@td@matAC*1cm},{\tikz@td@matBC*1cm})}}}%
\def\pgfmathparse@td@FPU#1{\begingroup%
\pgfkeys{/pgf/fpu,/pgf/fpu/output format=fixed}%
\pgfmathparse{#1}%
\pgfmathsmuggle\pgfmathresult\endgroup}%
%
\newlength\pgf@X% not clear if one should use lengths here at all
\newlength\pgf@Y% 
\newlength\pgf@Z% 
\newlength\pgf@Xa% 
\newlength\pgf@Ya% 
\newlength\pgf@Za% 
\newlength\pgf@Xb% 
\newlength\pgf@Yb% 
\newlength\pgf@Zb% 
\xdef\tikz@td@type{0}%0=linear combination,1=vector product
\long\def\RawCoord(#1){\csname tikz@dcl@coord@#1\endcsname}% 
\long\def\ParseCoord(#1){%
\pgfutil@tempcnta=0%
\pgfutil@for\pgf@tmp:={#1}\do{\advance\pgfutil@tempcnta by1}%
\ifnum\the\pgfutil@tempcnta=1
\edef\pgfutil@tmp{\csname tikz@dcl@coord@#1\endcsname}% 
\else%
\edef\pgfutil@tmp{(#1)}%
\fi%
\pgfmathparse@td@FPU{xcomp3(\pgfutil@tmp)}% 
\pgf@X=\pgfmathresult pt% 
\pgfmathparse@td@FPU{ycomp3(\pgfutil@tmp)}% 
\pgf@Y=\pgfmathresult pt% 
\pgfmathparse@td@FPU{zcomp3(\pgfutil@tmp)}% 
\pgf@Z=\pgfmathresult pt}%
\pgfmathdeclarefunction{TD}{1}{%
\begingroup%
\pgfmathtdparse{#1}%
\pgfmathsmuggle\pgfmathresult\endgroup%
}%
% projections 
\pgfmathdeclarefunction{xcomp3}{3}{% x component of a 3-vector 
\begingroup% 
\pgfmathparse@td@FPU{#1}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
\pgfmathdeclarefunction{ycomp3}{3}{% y component of a 3-vector 
\begingroup% 
\pgfmathparse@td@FPU{#2}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
\pgfmathdeclarefunction{zcomp3}{3}{% z component of a 3-vector 
\begingroup% 
\pgfmathparse@td@FPU{#3}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
\pgfmathdeclarefunction{TDx}{1}{% x component of a 3-vector 
\begingroup% 
\edef\mycoord{\RawCoord(#1)}%
\pgfmathparse@td@FPU{xcomp3\mycoord}% 
\pgfmathsmuggle\pgfmathresult\endgroup}%
\pgfmathdeclarefunction{TDy}{1}{% x component of a 3-vector 
\begingroup% 
\edef\mycoord{\RawCoord(#1)}%
\pgfmathparse@td@FPU{ycomp3\mycoord}% 
\pgfmathsmuggle\pgfmathresult\endgroup}%
\pgfmathdeclarefunction{TDz}{1}{% x component of a 3-vector 
\begingroup% 
\edef\mycoord{\RawCoord(#1)}%
\pgfmathparse@td@FPU{zcomp3\mycoord}% 
\pgfmathsmuggle\pgfmathresult\endgroup}%
\def\scalprod#1=#2.#3;{% 
\edef\coordA{\RawCoord#2}% 
\edef\coordB{\RawCoord#3}% 
\pgfmathsetmacro\pgfutil@tmpa{scalarproduct({\coordA},{\coordB})}% 
\edef#1{\pgfutil@tmpa}}% 
\def\spaux#1#2#3#4#5#6{(#1)*(#4)+(#2)*(#5)+(#3)*(#6)}% 
\pgfmathdeclarefunction{scalarproduct}{2}{% scalar product of two 3-vectors 
\begingroup% 
\pgfmathparse@td@FPU{\spaux#1#2}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
% vector product 
% vector product auxiliary functions 
\def\vpauxx#1#2#3#4#5#6{(#2)*(#6)-(#3)*(#5)}% 
\def\vpauxy#1#2#3#4#5#6{(#4)*(#3)-(#1)*(#6)}% 
\def\vpauxz#1#2#3#4#5#6{(#1)*(#5)-(#2)*(#4)}% 
% vector product pgf functions 
\pgfmathdeclarefunction{vpx}{2}{% x component of vector product 
\begingroup% 
\pgfmathparse@td@FPU{\vpauxx#1#2}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
\pgfmathdeclarefunction{vpy}{2}{% y component of vector product 
\begingroup% 
\pgfmathparse@td@FPU{\vpauxy#1#2}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
\pgfmathdeclarefunction{vpz}{2}{% z component of vector product 
\begingroup% 
\pgfmathparse@td@FPU{\vpauxz#1#2}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
%
%
% the following is very much "inspired" by the calc library 
\long\def\pgfmathtdparse#1{% < and > really are placeholders for a later integration
\begingroup% into calc, which however requires changes both in
% tikzlibrarycalc.code.tex and in tikz.code.tex
% 
% tdparse main computation. It's a series of optional factors in front 
% of coordinates. It is very much copied from the calc library. 
% 
\pgf@Xa=0pt% We accumulate the result in here. 
\pgf@Ya=0pt% 
\pgf@Za=0pt% 
\tikz@td@cc@parse+#1% 
}% 

\def\tikz@td@cc@parse{% 
\pgfutil@ifnextchar>{% 
% Ok, we found the end... 
\tikz@td@cc@end% 
} 
{\pgfutil@ifnextchar+{% 
% Ok, we found a coordinate... 
\tikz@td@cc@add% 
}{% 
\pgfutil@ifnextchar-{% 
\tikz@td@cc@sub% 
}{% 
\pgfutil@ifnextchar x{% 
\tikz@td@cc@vecprod% 
}{% 
\pgfutil@ifnextchar o{% 
\tikz@td@cc@scalprod% 
}{% \tikzerror{+ or - expected}% 
\tikz@td@cc@end%
}% 
}% 
}% 
}% 
}%
}%
% 
% The end is reached with > at the moment but this should change 
% 
\def\tikz@td@cc@end{% 
\ifcase\tikz@td@type%
\pgfmathsetmacro{\pgftemp@x}{\pgf@Xa}% 
\pgfmathsetmacro{\pgftemp@y}{\pgf@Ya}% 
\pgfmathsetmacro{\pgftemp@z}{\pgf@Za}% 
\edef\pgfmathresult{\pgftemp@x,\pgftemp@y,\pgftemp@z}%
\or%
\pgfmathsetmacro{\myxa}{\pgf@Xa}%
\pgfmathsetmacro{\myya}{\pgf@Ya}%
\pgfmathsetmacro{\myza}{\pgf@Za}%
\pgfmathsetmacro{\myxb}{\pgf@Xb}%
\pgfmathsetmacro{\myyb}{\pgf@Yb}%
\pgfmathsetmacro{\myzb}{\pgf@Zb}%
\pgfmathsetmacro{\pgftemp@x}{\vpauxx{\myxb}{\myyb}{\myzb}{\myxa}{\myya}{\myza}}% 
\pgfmathsetmacro{\pgftemp@y}{\vpauxy{\myxb}{\myyb}{\myzb}{\myxa}{\myya}{\myza}}% 
\pgfmathsetmacro{\pgftemp@z}{\vpauxz{\myxb}{\myyb}{\myzb}{\myxa}{\myya}{\myza}}% 
%\typeout{P1=(\myxb,\myyb,\myzb),P2=(\myxa,\myya,\myza),P1xP2=(\pgftemp@x,\pgftemp@y,\pgftemp@z)}%
\edef\pgfmathresult{\pgftemp@x,\pgftemp@y,\pgftemp@z}%
\or%
\pgfmathsetmacro{\myxa}{\pgf@Xa}%
\pgfmathsetmacro{\myya}{\pgf@Ya}%
\pgfmathsetmacro{\myza}{\pgf@Za}%
\pgfmathsetmacro{\myxb}{\pgf@Xb}%
\pgfmathsetmacro{\myyb}{\pgf@Yb}%
\pgfmathsetmacro{\myzb}{\pgf@Zb}%
\pgfmathparse@td@FPU{\myxa*\myxb+\myya*\myyb+\myza*\myzb}%
%\typeout{P1=(\myxb,\myyb,\myzb),P2=(\myxa,\myya,\myza),P1.P2=(\pgmfmathresult)}%
\fi%
%\message{result = (\pgftemp@x,\pgftemp@y,\pgftemp@z)=\pgfmathresult^^J}%
\xdef\tikz@td@type{0}% reset type to linear combination
\pgfmathsmuggle\pgfmathresult\endgroup}% 
% 
\def\tikz@td@cc@add+{% 
\def\tikz@td@cc@factor{1}% 
\tikz@td@cc@factororcoordinate% 
}% 
\def\tikz@td@cc@sub-{% 
\def\tikz@td@cc@factor{-1}% 
\tikz@td@cc@factororcoordinate% 
}% 
\def\tikz@td@cc@vecprod x{% 
%\message{Ah, a vector product^^J}%
\xdef\tikz@td@type{1}%
\pgf@Xb=\pgf@Xa% store current vector in b
\pgf@Yb=\pgf@Ya%
\pgf@Zb=\pgf@Za%
\pgf@Xa=0pt% reset a
\pgf@Ya=0pt%
\pgf@Za=0pt%
\def\tikz@td@cc@factor{1}%
\tikz@td@cc@factororcoordinate% 
}%
\def\tikz@td@cc@scalprod o{% 
%\message{Ah, a scalar product^^J}%
\xdef\tikz@td@type{2}%
\pgf@Xb=\pgf@Xa% store current vector in b
\pgf@Yb=\pgf@Ya%
\pgf@Zb=\pgf@Za%
\pgf@Xa=0pt% reset a
\pgf@Ya=0pt%
\pgf@Za=0pt%
\def\tikz@td@cc@factor{1}%
\tikz@td@cc@factororcoordinate% 
}%
% 
% Check for a factor: If we see a (, its a coordinate... 
% 
\def\tikz@td@cc@factororcoordinate{% 
\pgfutil@ifnextchar({%) 
% Ok, found coordinate 
\tikz@td@cc@coordinate% 
}{% 
\tikz@td@cc@parse@factor% 
}% 
}% 
% 
% ... otherwise it's a factor. It ends at ...*( 
% 
\def\tikz@td@cc@parse@factor#1*({% 
\pgfmathparse@td@FPU{#1*\tikz@td@cc@factor}% 
\let\tikz@td@cc@factor=\pgfmathresult% 
\tikz@td@cc@coordinate(%) 
}% 
\def\tikz@td@cc@coordinate(#1){% 
\ParseCoord(#1)% 
\advance\pgf@Xa by\tikz@td@cc@factor\pgf@X 
\advance\pgf@Ya by\tikz@td@cc@factor\pgf@Y 
\advance\pgf@Za by\tikz@td@cc@factor\pgf@Z 
\tikz@td@cc@parse% 
}% 
\tikzset{declare function={torusx(\u,\v,\R,\r)=cos(\u)*(\R + \r*cos(\v)); 
torusy(\u,\v,\R,\r)=(\R + \r*cos(\v))*sin(\u);
torusz(\u,\v,\R,\r)=\r*sin(\v);
vcrit1(\u,\th)=atan(tan(\th)*sin(\u));% first critical v value
vcrit2(\u,\th)=180+atan(tan(\th)*sin(\u));% second critical v value
vtest(\u,\v,\az,\el)=sin(-vcrit1(\u-\az,\el)+\v);
disc(\th,\R,\r)=((pow(\r,2)-pow(\R,2))*pow(cot(\th),2)+% 
pow(\r,2)*(2+pow(tan(\th),2)))/pow(\R,2);% discriminant
umax(\th,\R,\r)=ifthenelse(disc(\th,\R,\r)>0,asin(sqrt(abs(disc(\th,\R,\r)))),0);
}}%
%
\tikzset{3d parse/.style={/utils/exec=\pgfmathtdparse{#1},%
insert path={(\pgfmathresult)}},3d coordinate/.style args={#1=#2}{%
/utils/exec=\pgfmathtdparse{#2},%
insert path={(\pgfmathresult) coordinate #1}}}%
\def\pgfmathprintvector#1{%
\pgfutil@tempcnta=0%
\pgfutil@for\pgf@tmp:={#1}\do{\advance\pgfutil@tempcnta by1}%
\pgfutil@tempcntb=1%
\pgfutil@for\pgf@tmp:={#1}\do{\advance\pgfutil@tempcntb by1%
\ifnum\the\pgfutil@tempcntb<\the\pgfutil@tempcnta
\pgfmathprintnumber\pgf@tmp,%
\else
\pgfmathprintnumber\pgf@tmp
\fi}%
}
\makeatother
\endinput
