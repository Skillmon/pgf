\newlength\pgf@X% 
\newlength\pgf@Y% 
\newlength\pgf@Z% 
\newlength\pgf@Xa% 
\newlength\pgf@Ya% 
\newlength\pgf@Za% 
\newlength\pgf@Xb% 
\newlength\pgf@Yb% 
\newlength\pgf@Zb% 
\xdef\tikz@td@type{0}%0=linear combination,1=vector product
\long\def\RawCoord(#1){\csname tikz@dcl@coord@#1\endcsname}% 
\long\def\ParseCoord(#1){\edef\pgfutil@tmp{\csname tikz@dcl@coord@#1\endcsname}% 
\pgfmathparse{xcomp3(\pgfutil@tmp)}% 
\pgf@X=\pgfmathresult pt% 
\pgfmathparse{ycomp3(\pgfutil@tmp)}% 
\pgf@Y=\pgfmathresult pt% 
\pgfmathparse{zcomp3(\pgfutil@tmp)}% 
\pgf@Z=\pgfmathresult pt}%
\pgfmathdeclarefunction{TD}{1}{%
\begingroup%
\tdparse<#1>%
\pgfmathsmuggle\pgfmathresult\endgroup%
}%
% projections 
\pgfmathdeclarefunction{xcomp3}{3}{% x component of a 3-vector 
\begingroup% 
\pgfmathparse{#1}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
\pgfmathdeclarefunction{ycomp3}{3}{% y component of a 3-vector 
\begingroup% 
\pgfmathparse{#2}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
\pgfmathdeclarefunction{zcomp3}{3}{% z component of a 3-vector 
\begingroup% 
\pgfmathparse{#3}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
\def\scalprod#1=#2.#3;{% 
\edef\coordA{\RawCoord#2}% 
\edef\coordB{\RawCoord#3}% 
\pgfmathsetmacro\pgfutil@tmpa{scalarproduct({\coordA},{\coordB})}% 
\edef#1{\pgfutil@tmpa}}% 
\newcommand{\spaux}[6]{(#1)*(#4)+(#2)*(#5)+(#3)*(#6)}% 
\pgfmathdeclarefunction{scalarproduct}{2}{% scalar product of two 3-vectors 
\begingroup% 
\pgfmathparse{\spaux#1#2}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
% vector product 
% vector product auxiliary functions 
\newcommand{\vpauxx}[6]{(#2)*(#6)-(#3)*(#5)}% 
\newcommand{\vpauxy}[6]{(#4)*(#3)-(#1)*(#6)}% 
\newcommand{\vpauxz}[6]{(#1)*(#5)-(#2)*(#4)}% 
% vector product pgf functions 
\pgfmathdeclarefunction{vpx}{2}{% x component of vector product 
\begingroup% 
\pgfmathparse{\vpauxx#1#2}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
\pgfmathdeclarefunction{vpy}{2}{% y component of vector product 
\begingroup% 
\pgfmathparse{\vpauxy#1#2}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
\pgfmathdeclarefunction{vpz}{2}{% z component of vector product 
\begingroup% 
\pgfmathparse{\vpauxz#1#2}% 
\pgfmathsmuggle\pgfmathresult\endgroup} 
%
%
% the following is very much "inspired" by the calc library 
\long\def\tdparse<#1>{% < and > really are placeholders for a later integration
\begingroup% into calc, which however requires changes both in
% tikzlibrarycalc.code.tex and in tikz.code.tex
% 
% tdparse main computation. It's a series of optional factors in front 
% of coordinates. It is very much copied from the calc library. 
% 
\pgf@Xa=0pt% We accumulate the result in here. 
\pgf@Ya=0pt% 
\pgf@Za=0pt% 
\tikz@td@cc@parse+#1% 
}% 

\def\tikz@td@cc@parse{% 
\pgfutil@ifnextchar>{% 
% Ok, we found the end... 
\tikz@td@cc@end% 
} 
{\pgfutil@ifnextchar+{% 
% Ok, we found a coordinate... 
\tikz@td@cc@add% 
}{% 
\pgfutil@ifnextchar-{% 
\tikz@td@cc@sub% 
}{% 
\pgfutil@ifnextchar x{% 
\tikz@td@cc@vecprod% 
}{% 
\pgfutil@ifnextchar o{% 
\tikz@td@cc@scalprod% 
}{% \tikzerror{+ or - expected}% 
\tikz@td@cc@end%
}% 
}% 
}% 
}% 
}%
}%
% 
% The end is reached with ; at the moment but this should change 
% 
\def\tikz@td@cc@end{% 
\ifcase\tikz@td@type%
\pgfmathsetmacro{\pgftemp@x}{\pgf@Xa}% 
\pgfmathsetmacro{\pgftemp@y}{\pgf@Ya}% 
\pgfmathsetmacro{\pgftemp@z}{\pgf@Za}% 
\edef\pgfmathresult{\pgftemp@x,\pgftemp@y,\pgftemp@z}%
\or%
\pgfmathsetmacro{\myxa}{\pgf@Xa}%
\pgfmathsetmacro{\myya}{\pgf@Ya}%
\pgfmathsetmacro{\myza}{\pgf@Za}%
\pgfmathsetmacro{\myxb}{\pgf@Xb}%
\pgfmathsetmacro{\myyb}{\pgf@Yb}%
\pgfmathsetmacro{\myzb}{\pgf@Zb}%
\pgfmathsetmacro{\pgftemp@x}{\vpauxx{\myxb}{\myyb}{\myzb}{\myxa}{\myya}{\myza}}% 
\pgfmathsetmacro{\pgftemp@y}{\vpauxy{\myxb}{\myyb}{\myzb}{\myxa}{\myya}{\myza}}% 
\pgfmathsetmacro{\pgftemp@z}{\vpauxz{\myxb}{\myyb}{\myzb}{\myxa}{\myya}{\myza}}% 
%\typeout{P1=(\myxb,\myyb,\myzb),P2=(\myxa,\myya,\myza),P1xP2=(\pgftemp@x,\pgftemp@y,\pgftemp@z)}%
\edef\pgfmathresult{\pgftemp@x,\pgftemp@y,\pgftemp@z}%
\or%
\pgfmathsetmacro{\myxa}{\pgf@Xa}%
\pgfmathsetmacro{\myya}{\pgf@Ya}%
\pgfmathsetmacro{\myza}{\pgf@Za}%
\pgfmathsetmacro{\myxb}{\pgf@Xb}%
\pgfmathsetmacro{\myyb}{\pgf@Yb}%
\pgfmathsetmacro{\myzb}{\pgf@Zb}%
\pgfmathparse{\myxa*\myxb+\myya*\myyb+\myza*\myzb}%
%\typeout{P1=(\myxb,\myyb,\myzb),P2=(\myxa,\myya,\myza),P1.P2=(\pgmfmathresult)}%
\fi%
%\message{result = (\pgftemp@x,\pgftemp@y,\pgftemp@z)=\pgfmathresult^^J}%
\xdef\tikz@td@type{0}% reset type to linear combination
\pgfmathsmuggle\pgfmathresult\endgroup}% 
% 
\def\tikz@td@cc@add+{% 
\def\tikz@td@cc@factor{1}% 
\tikz@td@cc@factororcoordinate% 
}% 
\def\tikz@td@cc@sub-{% 
\def\tikz@td@cc@factor{-1}% 
\tikz@td@cc@factororcoordinate% 
}% 
\def\tikz@td@cc@vecprod x{% 
%\message{Ah, a vector product^^J}%
\xdef\tikz@td@type{1}%
\pgf@Xb=\pgf@Xa% store current vector in b
\pgf@Yb=\pgf@Ya%
\pgf@Zb=\pgf@Za%
\pgf@Xa=0pt% reset a
\pgf@Ya=0pt%
\pgf@Za=0pt%
\def\tikz@td@cc@factor{1}%
\tikz@td@cc@factororcoordinate% 
}%
\def\tikz@td@cc@scalprod o{% 
%\message{Ah, a scalar product^^J}%
\xdef\tikz@td@type{2}%
\pgf@Xb=\pgf@Xa% store current vector in b
\pgf@Yb=\pgf@Ya%
\pgf@Zb=\pgf@Za%
\pgf@Xa=0pt% reset a
\pgf@Ya=0pt%
\pgf@Za=0pt%
\def\tikz@td@cc@factor{1}%
\tikz@td@cc@factororcoordinate% 
}%
% 
% Check for a factor: If we see a (, its a coordinate... 
% 
\def\tikz@td@cc@factororcoordinate{% 
\pgfutil@ifnextchar({%) 
% Ok, found coordinate 
\tikz@td@cc@coordinate% 
}{% 
\tikz@td@cc@parse@factor% 
}% 
}% 
% 
% ... otherwise it's a factor. It ends at ...*( 
% 
\def\tikz@td@cc@parse@factor#1*({% 
\pgfmathparse{#1*\tikz@td@cc@factor}% 
\let\tikz@td@cc@factor=\pgfmathresult% 
\tikz@td@cc@coordinate(%) 
}% 
\def\tikz@td@cc@coordinate(#1){% 
\ParseCoord(#1)% 
\advance\pgf@Xa by\tikz@td@cc@factor\pgf@X 
\advance\pgf@Ya by\tikz@td@cc@factor\pgf@Y 
\advance\pgf@Za by\tikz@td@cc@factor\pgf@Z 
\tikz@td@cc@parse% 
}% 